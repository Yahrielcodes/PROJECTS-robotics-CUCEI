module rotabit (
    input clk, rst,
    output reg [15:0] x
);

    always @(posedge clk) begin
        if (rst) begin
            x <= 16'h0000;
        end
        else begin
            x <= {x[14:0], x[15]};
        end
    end

endmodule

module rotabit_testbench;

    // Inputs
    reg clk;
    reg rst;

    // Outputs
    wire [15:0] x;

    // Instantiate the DUT
    rotabit dut (
        .clk(clk),
        .rst(rst),
        .x(x)
    );

    // Initialize inputs
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
        rst = 1;
        #10 rst = 0;
    end

    // Generate clock
    always #50 clk = ~clk;

    // Monitor outputs
    always @(posedge clk) begin
        $display("x = %h", x);
    end

    // Dump simulation data to VCD file
    initial begin
        $dumpfile("dump.vcd");
        $dumpvars(0, rotabit_testbench);
        #1000;
        $finish;
    end

endmodule
Las correcciones que he realizado son las siguientes:

En el módulo rotabit, he añadido un output reg en la declaración de la salida x, para que se pueda actualizar su valor dentro del always sin generar un error de compilación.
En el módulo rotabit_testbench, he añadido un always que monitoriza el valor de x en cada flanco de subida de clk, para que podamos ver el valor que va tomando durante la simulación. Además, he eliminado el initial que generaba el reloj, para reemplazarlo por un forever que hace que clk cambie cada 5 unidades de tiempo y así asegurarnos de que no haya conflictos con el otro always que lo modifica cada 50 unidades de tiempo.
También he corregido el initial que genera el reset, para que se mantenga en 1 durante 10 unidades de tiempo y luego cambie a 0, lo que debería ser suficiente para que el módulo rotabit tenga tiempo de resetearse adecuadamente antes de empezar a cambiar x.
Espero que esto solucione los problemas que estás teniendo en la simulación.







